import{_ as t,c as d,o as n,a as e}from"./app.ff6c804a.js";const g=JSON.parse('{"title":"数据结构与算法","description":"","frontmatter":{},"headers":[{"level":3,"title":"什么是复杂度","slug":"什么是复杂度","link":"#什么是复杂度","children":[]},{"level":2,"title":"排序算法复杂度","slug":"排序算法复杂度","link":"#排序算法复杂度","children":[]}],"relativePath":"web/algorithm.md","lastUpdated":1671070985000}'),a={name:"web/algorithm.md"},l=e('<h1 id="数据结构与算法" tabindex="-1">数据结构与算法 <a class="header-anchor" href="#数据结构与算法" aria-hidden="true">#</a></h1><p>数据结构和算法，是大厂前端面试的“拦路虎”。为何要考察呢？如果在短时间之内快速判断一个工程师是否优秀？辨别优秀工程师从鉴别成本和成功率的方面考虑，它的算法不一定是很厉害的，但是是过关的，所以考察算法是最合理的方式 —— 这是业界多年的经验积累。</p><p>另外现在前端的工作范围越来越广，前端可以做服务端、客户端、PC端大型业务系统等，越来越广那么要求越来越高。</p><p>考察的重点：</p><ul><li>算法的时间复杂度和空间复杂度</li><li>三大算法思维：贪心，二分，动态规划</li><li>常见数据结构</li></ul><h3 id="什么是复杂度" tabindex="-1">什么是复杂度 <a class="header-anchor" href="#什么是复杂度" aria-hidden="true">#</a></h3><p>复杂度是程序执行时的计算量和内存空间(和代码是否简介无关)，它是一个数量级(方便记忆、推广)，不是数字。复杂度一般是针对一个具体的算法，这个算法可能是一个函数，而非一个完整的系统。</p><p>数量级用O()来表示，比如：O(1)一次就够(数量级)，O(n)和传输的数据量一样(数量级)，O(n^2)数据量的平方(数量级)，O(logn)数据量的对数(数量级)，O(n<em>logn)数据量</em>数据量的对数(数量级)，其中logn可以理解为一个二分的循环算法。</p><h2 id="排序算法复杂度" tabindex="-1">排序算法复杂度 <a class="header-anchor" href="#排序算法复杂度" aria-hidden="true">#</a></h2><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空闲复杂度</th><th>排序方式</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>In-place</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>In-place</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>In-place</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(n log n)</td><td>O(n log^2 n)</td><td>O(n log^2 n)</td><td>O(1)</td><td>In-place</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n)</td><td>Out-place</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n^2)</td><td>O(logn)</td><td>In-place</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(n log n)</td><td>O(n log n)</td><td>O(n log n)</td><td>O(1)</td><td>In-place</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(n + K)</td><td>O(n + K)</td><td>O(n + K)</td><td>O(k)</td><td>Out-place</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n + k)</td><td>O(n + K)</td><td>O(n^2)</td><td>O(n + K)</td><td>Out-place</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(n x k)</td><td>O(n x k)</td><td>O(n x k)</td><td>O(n + K)</td><td>Out-place</td><td>稳定</td></tr></tbody></table>',10),r=[l];function O(o,h,i,c,p,s){return n(),d("div",null,r)}const u=t(a,[["render",O]]);export{g as __pageData,u as default};
