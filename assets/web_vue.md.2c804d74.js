import{_ as i,c as l,b as e,t,a,o as r}from"./app.103cf496.js";const g=JSON.parse('{"title":"Vue面试题","description":"","frontmatter":{},"headers":[{"level":2,"title":"简单介绍Vue.js是什么?","slug":"简单介绍vue-js是什么","link":"#简单介绍vue-js是什么","children":[]},{"level":2,"title":"Vue的优缺点是什么?","slug":"vue的优缺点是什么","link":"#vue的优缺点是什么","children":[]},{"level":2,"title":"使用Vue的好处是什么?","slug":"使用vue的好处是什么","link":"#使用vue的好处是什么","children":[]},{"level":2,"title":"在Vue.js中怎么理解MVVM模式？","slug":"在vue-js中怎么理解mvvm模式","link":"#在vue-js中怎么理解mvvm模式","children":[]},{"level":2,"title":"Vue的生命周期是什么?","slug":"vue的生命周期是什么","link":"#vue的生命周期是什么","children":[]},{"level":2,"title":"第一次页面加载会触发哪几个钩子函数?","slug":"第一次页面加载会触发哪几个钩子函数","link":"#第一次页面加载会触发哪几个钩子函数","children":[]},{"level":2,"title":"v-if和v-show有什么区别?","slug":"v-if和v-show有什么区别","link":"#v-if和v-show有什么区别","children":[]},{"level":2,"title":"Vue组件中data为什么必须是函数?","slug":"vue组件中data为什么必须是函数","link":"#vue组件中data为什么必须是函数","children":[]},{"level":2,"title":"前后端渲染各自的优点?","slug":"前后端渲染各自的优点","link":"#前后端渲染各自的优点","children":[]},{"level":2,"title":"computed、methods、watch的区别?","slug":"computed、methods、watch的区别","link":"#computed、methods、watch的区别","children":[]},{"level":2,"title":"Vue的响应式原理是什么?","slug":"vue的响应式原理是什么","link":"#vue的响应式原理是什么","children":[]},{"level":2,"title":"Vue中Key值的作用是什么?","slug":"vue中key值的作用是什么","link":"#vue中key值的作用是什么","children":[]},{"level":2,"title":"在Vue中做数据渲染的时候，如何保证将数据原样输出?","slug":"在vue中做数据渲染的时候-如何保证将数据原样输出","link":"#在vue中做数据渲染的时候-如何保证将数据原样输出","children":[]},{"level":2,"title":"Vue的双向数据绑定原理是什么?","slug":"vue的双向数据绑定原理是什么","link":"#vue的双向数据绑定原理是什么","children":[]},{"level":2,"title":"<transition>和<transition-group>有什么区别?","slug":"transition-和-transition-group-有什么区别","link":"#transition-和-transition-group-有什么区别","children":[]},{"level":2,"title":"Vue中data必须是一个函数吗?","slug":"vue中data必须是一个函数吗","link":"#vue中data必须是一个函数吗","children":[]},{"level":2,"title":"过渡动画实现的三种方式是什么?","slug":"过渡动画实现的三种方式是什么","link":"#过渡动画实现的三种方式是什么","children":[]},{"level":2,"title":"Vue组件间是如何传值通信的?","slug":"vue组件间是如何传值通信的","link":"#vue组件间是如何传值通信的","children":[]},{"level":2,"title":"请阐述Vue子组件调用父组件的几种方法?","slug":"请阐述vue子组件调用父组件的几种方法","link":"#请阐述vue子组件调用父组件的几种方法","children":[]},{"level":2,"title":"什么是虚拟DOM?","slug":"什么是虚拟dom","link":"#什么是虚拟dom","children":[]},{"level":2,"title":"$route和$router的区别?","slug":"route和-router的区别","link":"#route和-router的区别","children":[]},{"level":2,"title":"vue-router有哪几种导航钩子?","slug":"vue-router有哪几种导航钩子","link":"#vue-router有哪几种导航钩子","children":[]}],"relativePath":"web/vue.md","lastUpdated":1668099283000}'),d={name:"web/vue.md"},u=a('<h1 id="vue面试题" tabindex="-1">Vue面试题 <a class="header-anchor" href="#vue面试题" aria-hidden="true">#</a></h1><h2 id="简单介绍vue-js是什么" tabindex="-1">简单介绍Vue.js是什么? <a class="header-anchor" href="#简单介绍vue-js是什么" aria-hidden="true">#</a></h2><p>Vue.js是一款用于构建用户界面的渐进式框架。渐进式框架是Vue.js相比于Angular较为受开发者喜欢的原因之一。这意味着，Vue.js是一个无论项目大小都可以满足开发需求的框架。通俗地讲，Vue.js就是一间已经搭建好的“空屋”。与单纯使用jQuery这种库相比，Vue.js可以更好地实现代码复用、减少工作量。</p><h2 id="vue的优缺点是什么" tabindex="-1">Vue的优缺点是什么? <a class="header-anchor" href="#vue的优缺点是什么" aria-hidden="true">#</a></h2><p>优点：1. 前端专门负责前端页面和特效的编写，后端专门负责后端业务逻辑的处理；2. 前端追求的是页面美观、页面流畅、页面兼容等，而后端追求的是“三高”（高并发、高可用、高性能），让它们负责各自的领域，让专业人员负责处理专业的事情，提高开发效率。</p><p>缺点：1. 当接口发生改变的时候，前后端都需要改变；2. 当发生异常的时候，前后端需要联调。联调是非常浪费时间的。</p><h2 id="使用vue的好处是什么" tabindex="-1">使用Vue的好处是什么? <a class="header-anchor" href="#使用vue的好处是什么" aria-hidden="true">#</a></h2><p>Vue两大特点：响应式编程、组件化。Vue的优势：轻量级框架、简单易学、双向数据绑定、组件化、视图与数据和结构分离、虚拟DOM、运行速度快。</p><h2 id="在vue-js中怎么理解mvvm模式" tabindex="-1">在Vue.js中怎么理解MVVM模式？ <a class="header-anchor" href="#在vue-js中怎么理解mvvm模式" aria-hidden="true">#</a></h2><p>MVVM是Model View ViewModel的缩写。其中Model、View、ViewModel的作用分别如下。</p><ol><li>Model代表数据模型，可以在Model中定义数据修改和操作的业务逻辑。</li><li>View代表UI组件，负责将数据模型转换成UI展现出来。</li><li>ViewModel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View和Model的对象，连接Model和View。在MVVM架构下，View和Model之间并没有直接的联系，而是通过ViewModel进行交互。Model和ViewModel之间的交互是双向的，因此View数据的变化会同步到Model中，而Model数据的变化也会立即反映到View上。ViewModel通过双向数据绑定把View层和Model层连接了起来，而View和Model之间的同步工作完全是自动的，无须人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM、不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM统一管理。</li></ol><h2 id="vue的生命周期是什么" tabindex="-1">Vue的生命周期是什么? <a class="header-anchor" href="#vue的生命周期是什么" aria-hidden="true">#</a></h2><ol><li>beforeCreate()(创建前)在数据观测和初始化事件还未开始时被调用</li><li>created()(创建后)在完成数据观测、属性和方法的运算、初始化事件后被调用，$el属性还没有显示出来</li><li>beforeMount()(载入前)在挂载开始前被调用，相关的render函数首次被调用，实例已完成以下配置：编译模板，把data中的数据和模板生成.html。注意此时还没有挂载.html到页面上。</li><li>mounted()(载入后)在el被新创建的vm.$el替换，并挂载到实例上后被调用。实例已完成以下配置：用上面编译好的.html内容替换el属性指向的DOM对象。注意此时模板中的.html被渲染到.html页面中，此过程中进行Ajax交互。</li><li>beforeUpdate()(更新前)在数据更新前被调用，发生在虚拟DOM重新渲染和打补丁前。在该钩子函数中可以进一步更改状态，不会触发附加的重渲染过程。</li><li>updated()(更新后)在由于数据更改导致的虚拟DOM重新渲染和打补丁后被调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而，在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子函数在服务器端渲染期间不被调用。</li><li>beforeDestroy()(销毁前)在实例销毁前被调用，实例仍然完全可用。</li><li>destroyed()(销毁后)在实例销毁后被调用，调用后，所有的事件监听器会被移除、所有的子实例也会被销毁。该钩子函数在服务器端渲染期间不被调用。</li></ol><h2 id="第一次页面加载会触发哪几个钩子函数" tabindex="-1">第一次页面加载会触发哪几个钩子函数? <a class="header-anchor" href="#第一次页面加载会触发哪几个钩子函数" aria-hidden="true">#</a></h2><p>第一次会触发beforeCreate()、created()、beforeMount()、mounted()，并且在mounted()阶段DOM被渲染完成。</p><h2 id="v-if和v-show有什么区别" tabindex="-1">v-if和v-show有什么区别? <a class="header-anchor" href="#v-if和v-show有什么区别" aria-hidden="true">#</a></h2><ol><li>相同点：两者都是在判断DOM节点是否要显示。</li><li>不同点： <ul><li>实现方式。v-if是根据后面数据的真假值，判断直接从DOM树上删除或重建元素节点；v-show只是修改元素的CSS样式，也就是display的属性值，元素始终在DOM树上。</li><li>编译过程。v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单地基于CSS切换</li><li>编译条件。v-if是惰性的，如果初始条件为假，则什么也不做，只有在条件第一次变为真时才开始局部编译；v-show是在任何条件下（无论首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被保留。</li><li>性能消耗。v-if有较高的切换消耗，不适合做频繁的切换；而v-show有较高的初始渲染消耗，适合做频繁的切换。</li></ul></li></ol><h2 id="vue组件中data为什么必须是函数" tabindex="-1">Vue组件中data为什么必须是函数? <a class="header-anchor" href="#vue组件中data为什么必须是函数" aria-hidden="true">#</a></h2><p>在new Vue()中，data是可以作为一个对象进行操作的。然而，在component中，data只能以函数的形式存在，不能直接将对象赋值给它。</p><p>当data选项是一个函数的时候，每个实例可以维护一份被返回对象的独立备份，这样各个实例中的data不会相互影响，以确保是独立的。如果传给组件的data是一个原始对象，则在建立多个组件实例时，它们就会共用这个data对象，修改其中一个组件实例的数据就会影响其他组件实例的数据。</p><h2 id="前后端渲染各自的优点" tabindex="-1">前后端渲染各自的优点? <a class="header-anchor" href="#前后端渲染各自的优点" aria-hidden="true">#</a></h2><p>前端渲染的优点在于：</p><ol><li>业务分离，后端只需要提供数据接口，前端在开发时也不需要部署对应的后端环境，通过一些代理服务器工具就能远程获取后端数据进行开发，能够提升开发效率；</li><li>计算量转移，原本需要后端渲染的任务转移给了前端，减轻了服务器的压力。</li></ol><p>后端渲染的优点在于：</p><ol><li>对搜索引擎友好；</li><li>首页加载时间短，后端渲染加载完成后就直接显示HTML，但前端渲染在加载完成后还需要有一段JS渲染的时间。</li></ol><h2 id="computed、methods、watch的区别" tabindex="-1">computed、methods、watch的区别? <a class="header-anchor" href="#computed、methods、watch的区别" aria-hidden="true">#</a></h2><ol><li>computed：计算属性是用来声明式地描述一个值依赖了其他的值。当在模板中把数据绑定到一个计算属性上时，Vue会在其依赖的任何值导致该计算属性改变时更新DOM。这个功能是非常强大的，它可以让代码更加声明式、数据驱动且易于维护。</li><li>methods：methods函数绑定事件调用，不会使用缓存。</li><li>watch：监听的是定义的变量。当定义变量的值发生变化时，调用对应的方法。在<code>&lt;div&gt;</code>中编写一个表达式name，在data中写入num和lastname、firstname。在watch中，当num的值发生变化时，就会调用num的方法，方法里面的形参对应的是num的新值和旧值，而在computed中，计算的是name依赖的值，它不能计算在data中已经定义过的变量。</li></ol><h2 id="vue的响应式原理是什么" tabindex="-1">Vue的响应式原理是什么? <a class="header-anchor" href="#vue的响应式原理是什么" aria-hidden="true">#</a></h2><p>当一个Vue实例创建时，Vue会遍历data选项的属性，用Object.defineProperty将它们转为getter/setter，并在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的watcher实例，它会在组件渲染的过程中把属性记录为依赖，然后当依赖项的setter被调用时，会通知watcher重新计算，从而使它关联的组件得以更新。</p><h2 id="vue中key值的作用是什么" tabindex="-1">Vue中Key值的作用是什么? <a class="header-anchor" href="#vue中key值的作用是什么" aria-hidden="true">#</a></h2><p>使用Key来给每个节点做一个唯一标识，Key的作用主要是高效地更新虚拟DOM。另外，在Vue中使用相同标签名元素过渡切换时，也会使用到Key属性，其目的是让Vue可以区分它们，否则Vue只会替换其内部属性，而不会触发过渡效果。</p><h2 id="在vue中做数据渲染的时候-如何保证将数据原样输出" tabindex="-1">在Vue中做数据渲染的时候，如何保证将数据原样输出? <a class="header-anchor" href="#在vue中做数据渲染的时候-如何保证将数据原样输出" aria-hidden="true">#</a></h2>',32),h=e("li",null,"v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出。",-1),o=e("li",null,"v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染。",-1),n=a('<h2 id="vue的双向数据绑定原理是什么" tabindex="-1">Vue的双向数据绑定原理是什么? <a class="header-anchor" href="#vue的双向数据绑定原理是什么" aria-hidden="true">#</a></h2><p>Vue.js采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调。具体步骤如下:</p><p>第一步：需要对Observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter。这样给这个对象的某个属性赋值，就会触发setter，那么就能监听到数据变化了。</p><p>第二步：Compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者（一旦数据有变动，收到通知，更新视图）。</p><p>第三步：Watcher订阅者是Observer和Compile间通信的“桥梁”，主要负责做的事情如下。</p><ol><li>在自身实例化时往属性订阅器（dep）中添加自身。</li><li>自身必须有一个update()方法。待属性变动通知dep.notice()时，能调用自身的update()方法，并触发Compile中绑定的回调。</li></ol><p>第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的Model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile间的通信“桥梁”，达到“数据变化→视图更新、视图交互变化→Model数据变更”的双向绑定效果。</p><h2 id="transition-和-transition-group-有什么区别" tabindex="-1"><code>&lt;transition&gt;</code>和<code>&lt;transition-group&gt;</code>有什么区别? <a class="header-anchor" href="#transition-和-transition-group-有什么区别" aria-hidden="true">#</a></h2><p>唯一的区别就是<code>&lt;transition&gt;</code>中只能包裹一个元素，而<code>&lt;transition-group&gt;</code>可以包裹多个元素。</p><h2 id="vue中data必须是一个函数吗" tabindex="-1">Vue中data必须是一个函数吗? <a class="header-anchor" href="#vue中data必须是一个函数吗" aria-hidden="true">#</a></h2><p>对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，若在一个组件中修改data，其他重用组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，因此不会出现这个问题。</p><h2 id="过渡动画实现的三种方式是什么" tabindex="-1">过渡动画实现的三种方式是什么? <a class="header-anchor" href="#过渡动画实现的三种方式是什么" aria-hidden="true">#</a></h2><p>第一种：使用Vue的<code>&lt;transition&gt;</code>标签结合CSS样式完成动画。</p><p>第二种：利用Animate.css结合<code>&lt;transition&gt;</code>实现动画。</p><p>第三种：利用Vue中的钩子函数实现动画。</p><h2 id="vue组件间是如何传值通信的" tabindex="-1">Vue组件间是如何传值通信的? <a class="header-anchor" href="#vue组件间是如何传值通信的" aria-hidden="true">#</a></h2><ol><li>父组件与子组件传值。 <ul><li>父组件传值给子组件：子组件通过props方法接收数据。</li><li>子组件传值给父组件：用$emit方法传递参数。</li></ul></li><li>非父子组件间的数据传递，如兄弟组件间传值：用eventBus创建一个事件中心（相当于中转站），用来传递事件和接收事件。此外，也可以用Vuex来实现。</li></ol><h2 id="请阐述vue子组件调用父组件的几种方法" tabindex="-1">请阐述Vue子组件调用父组件的几种方法? <a class="header-anchor" href="#请阐述vue子组件调用父组件的几种方法" aria-hidden="true">#</a></h2><ol><li>直接在子组件中通过this.$parent.event来调用父组件的方法。</li><li>在子组件中用$emit向父组件触发一个事件，父组件监听这个事件。</li></ol><h2 id="什么是虚拟dom" tabindex="-1">什么是虚拟DOM? <a class="header-anchor" href="#什么是虚拟dom" aria-hidden="true">#</a></h2><p>虚拟DOM其实就是一棵以JavaScript对象（VNode节点）作为基础的树，用对象属性来描述节点。实际上，它只是一层对真实DOM的抽象，最终可以通过一系列操作使这棵树映射到真实环境上。</p><p>简单来说，可以把虚拟DOM理解为一个简单的JavaScript对象，并且最少包含标签名（tag）、属性（attrs）和子元素对象（children）三个属性。不同的框架对这三个属性的命名会有所区别。</p><h2 id="route和-router的区别" tabindex="-1">$route和$router的区别? <a class="header-anchor" href="#route和-router的区别" aria-hidden="true">#</a></h2><p>$route是“路由信息”对象，包括path、params、hash、query、fullPath、matched、name等路由信息参数。而$router是“路由实例”对象，包括路由的跳转方法、钩子函数等。</p><h2 id="vue-router有哪几种导航钩子" tabindex="-1">vue-router有哪几种导航钩子? <a class="header-anchor" href="#vue-router有哪几种导航钩子" aria-hidden="true">#</a></h2><ol><li>全局导航钩子。router.beforeEach(to,from,next)，作用是跳转前进行判断拦截。</li><li>组件内的钩子。</li><li>单独路由独享组件。</li></ol>',26);function s(c,v,p,V,m,M){return r(),l("div",null,[u,e("ol",null,[h,o,e("li",null,t()+"：插值表达式，可以直接获取Vue实例中定义的数据或函数。使用插值表达式的时候，值可能闪烁；而使用v-html、v-text时不会闪烁，有值就显示，没有值就会被隐藏。",1)]),n])}const _=i(d,[["render",s]]);export{g as __pageData,_ as default};
