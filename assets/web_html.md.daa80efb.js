import{_ as a,o as l,c as s,V as e}from"./chunks/framework.0b5b95cd.js";const t="/interview/images/18.png",F=JSON.parse('{"title":"HTML面试题","description":"","frontmatter":{},"headers":[],"relativePath":"web/html.md","filePath":"web/html.md","lastUpdated":1683274969000}'),n={name:"web/html.md"},o=e(`<h1 id="html面试题" tabindex="-1">HTML面试题 <a class="header-anchor" href="#html面试题" aria-label="Permalink to &quot;HTML面试题&quot;">​</a></h1><h2 id="对-html-语义化的理解" tabindex="-1">对 HTML 语义化的理解 <a class="header-anchor" href="#对-html-语义化的理解" aria-label="Permalink to &quot;对 HTML 语义化的理解&quot;">​</a></h2><p>语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于 SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><p>常见的语义化标签：</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">header</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">header</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">     头部</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">nav</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">nav</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">           导航栏</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">section</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">section</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">   区块(有语义化的div)</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">main</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">main</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">         主要区域</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">article</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">article</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">   主要内容</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">aside</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">aside</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">       侧边栏</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">footer</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">footer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">     底部</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="doctype-文档类型-的作用" tabindex="-1">DOCTYPE(⽂档类型) 的作用 <a class="header-anchor" href="#doctype-文档类型-的作用" aria-label="Permalink to &quot;DOCTYPE(⽂档类型) 的作用&quot;">​</a></h2><p>DOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器（解析器）应该以什么样（html 或 xhtml）的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 代码甚⾄JavaScript 脚本的解析。它必须声明在 HTML⽂档的第⼀⾏。</p><p>浏览器渲染页面的两种模式（可通过 document.compatMode 获取，比如，语雀官网的文档类型是 CSS1Compat）</p><ul><li>CSS1Compat：标准模式（Strick mode），默认模式，浏览器使用 W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li><li>BackCompat：怪异模式(混杂模式)(Quick mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li></ul><h2 id="script-标签中-defer-和-async-的区别" tabindex="-1">script 标签中 defer 和 async 的区别 <a class="header-anchor" href="#script-标签中-defer-和-async-的区别" aria-label="Permalink to &quot;script 标签中 defer 和 async 的区别&quot;">​</a></h2><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p><p>下图可以直观的看出三者之间的区别: <img src="`+t+'" alt=""> 其中蓝色代表 js 脚本网络加载时间，红色代表 js 脚本执行时间，绿色代表 html 解析。</p><p>defer 和 async 属性都是去异步加载外部的 JS 脚本文件，它们都不会阻塞页面的解析，其区别如下：</p><ul><li>执行顺序：多个带 async 属性的标签，不能保证加载的顺序；多个带defer 属性的标签，按照加载顺序执行；</li><li>脚本是否并行执行：async 属性，表示后续文档的加载和执行与 js脚本的加载和执行是并行进行的，即异步执行；defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded 事件触发执行之前。</li></ul><h2 id="行内元素有哪些-块级元素有哪些-空-void-元素有那些" tabindex="-1">行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ <a class="header-anchor" href="#行内元素有哪些-块级元素有哪些-空-void-元素有那些" aria-label="Permalink to &quot;行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？&quot;">​</a></h2><p>行内元素有：<code>a b span img input select strong</code>；</p><p>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</p><p>空元素，即没有内容的 HTML 元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p><p>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</p><p>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</p><h2 id="浏览器是如何对-html5-的离线储存资源进行管理和加载" tabindex="-1">浏览器是如何对 HTML5 的离线储存资源进行管理和加载？ <a class="header-anchor" href="#浏览器是如何对-html5-的离线储存资源进行管理和加载" aria-label="Permalink to &quot;浏览器是如何对 HTML5 的离线储存资源进行管理和加载？&quot;">​</a></h2><ul><li>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li><li>离线的情况下，浏览器会直接使用离线存储的资源。</li></ul><h2 id="canvas-和-svg-的区别" tabindex="-1">Canvas 和 SVG 的区别 <a class="header-anchor" href="#canvas-和-svg-的区别" aria-label="Permalink to &quot;Canvas 和 SVG 的区别&quot;">​</a></h2><ol><li>SVG</li></ol><p>SVG 可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言 XML 描述的 2D 图形的语言，SVG 基于 XML 就意味着 SVG DOM中的每个元素都是可用的，可以为某个元素附加 Javascript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>其特点如下：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><ol start="2"><li>Canvas Canvas 是画布，通过 Javascript 来绘制 2D 图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</li></ol><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p><h2 id="说一下-html5-drag-api" tabindex="-1">说一下 HTML5 drag API <a class="header-anchor" href="#说一下-html5-drag-api" aria-label="Permalink to &quot;说一下 HTML5 drag API&quot;">​</a></h2><ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li><li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li><li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li><li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li><li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li><li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li><li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li></ul>',35),p=[o];function c(r,i,d,h,m,D){return l(),s("div",null,p)}const u=a(n,[["render",c]]);export{F as __pageData,u as default};
