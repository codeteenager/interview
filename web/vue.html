<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue面试题 | 前端面试八股文</title>
    <meta name="description" content="前端面试八股文">
    <link rel="stylesheet" href="/interview/assets/style.159f4ae5.css">
    <link rel="modulepreload" href="/interview/assets/app.fbfe15fc.js">
    <link rel="modulepreload" href="/interview/assets/web_vue.md.4aeca890.lean.js">
    
    <link rel="icon" href="/interview/favicon.ico">
  <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-f44a984a><!--[--><!--]--><!--[--><span tabindex="-1" data-v-151f2593></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-151f2593> Skip to content </a><!--]--><!----><header class="VPNav" data-v-f44a984a data-v-8c0a9870><div class="VPNavBar has-sidebar" data-v-8c0a9870 data-v-1bbed88e><div class="container" data-v-1bbed88e><div class="VPNavBarTitle has-sidebar" data-v-1bbed88e data-v-d5925166><a class="title" href="/interview/" data-v-d5925166><!--[--><!--]--><!----><!--[-->前端面试八股文<!--]--><!--[--><!--]--></a></div><div class="content" data-v-1bbed88e><!--[--><!--]--><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-1bbed88e data-v-f83db6ba><span id="main-nav-aria-label" class="visually-hidden" data-v-f83db6ba>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/interview/web/algorithm.html" data-v-f83db6ba data-v-47a2263e data-v-3c355974><!--[-->前端面试题<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-1bbed88e data-v-a3e7452b><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-a3e7452b data-v-481098f9 data-v-eba7420e><span class="check" data-v-eba7420e><span class="icon" data-v-eba7420e><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-481098f9><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-481098f9><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-1bbed88e data-v-738bef5a data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/codeteenager/interview" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-1bbed88e data-v-e4361c82 data-v-6ffb57d3><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-6ffb57d3><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-6ffb57d3><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-6ffb57d3><div class="VPMenu" data-v-6ffb57d3 data-v-1c5d0cfc><!----><!--[--><!--[--><!----><div class="group" data-v-e4361c82><div class="item appearance" data-v-e4361c82><p class="label" data-v-e4361c82>Appearance</p><div class="appearance-action" data-v-e4361c82><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-e4361c82 data-v-481098f9 data-v-eba7420e><span class="check" data-v-eba7420e><span class="icon" data-v-eba7420e><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-481098f9><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-481098f9><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-e4361c82><div class="item social-links" data-v-e4361c82><div class="VPSocialLinks social-links-list" data-v-e4361c82 data-v-f6988cfb><!--[--><a class="VPSocialLink" href="https://github.com/codeteenager/interview" target="_blank" rel="noopener" data-v-f6988cfb data-v-e57698f6><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-1bbed88e data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-f44a984a data-v-b6162a8b><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-b6162a8b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-b6162a8b><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-b6162a8b>Menu</span></button><a class="top-link" href="#" data-v-b6162a8b> Return to top </a></div><aside class="VPSidebar" data-v-f44a984a data-v-a186aa16><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-a186aa16><span class="visually-hidden" id="sidebar-aria-label" data-v-a186aa16> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-a186aa16><section class="VPSidebarGroup" data-v-a186aa16 data-v-6e45c352><div class="title" data-v-6e45c352><h2 class="title-text" data-v-6e45c352>基础</h2><div class="action" data-v-6e45c352><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-6e45c352><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-6e45c352><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-6e45c352><!--[--><!--[--><a class="VPLink link link" href="/interview/web/introduction.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>介绍</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/interview/web/algorithm.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>数据结构与算法</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/interview/web/program.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>手写题</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/interview/web/javascript.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>JavaScript</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/interview/web/network.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>网络</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link active" href="/interview/web/vue.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>Vue面试题</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/interview/web/skills.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>面试套路</span><!--]--><!----></a><!----><!--]--><!--[--><a class="VPLink link link" href="/interview/web/other.html" style="padding-left:0px;" data-v-36b976d1 data-v-3c355974><!--[--><span class="link-text" data-v-36b976d1>其他面经</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-f44a984a data-v-d981fe29><div class="VPDoc has-sidebar has-aside" data-v-d981fe29 data-v-cfb513e0><div class="container" data-v-cfb513e0><div class="aside" data-v-cfb513e0><div class="aside-curtain" data-v-cfb513e0></div><div class="aside-container" data-v-cfb513e0><div class="aside-content" data-v-cfb513e0><div class="VPDocAside" data-v-cfb513e0 data-v-afc4c1a1><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-afc4c1a1 data-v-2865c0b0><div class="content" data-v-2865c0b0><div class="outline-marker" data-v-2865c0b0></div><div class="outline-title" data-v-2865c0b0>在本页面</div><nav aria-labelledby="doc-outline-aria-label" data-v-2865c0b0><span class="visually-hidden" id="doc-outline-aria-label" data-v-2865c0b0> Table of Contents for current page </span><ul class="root" data-v-2865c0b0 data-v-1188541a><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-afc4c1a1></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--[--><!--[--><!--[--><div class="content" data-v-0fdd4fd7><img class="icon" src="/interview/weixin.jpg" data-v-0fdd4fd7><span class="text" data-v-0fdd4fd7>微信公众号</span></div><!--]--><!--]--><!--]--><!--]--></div></div></div></div><div class="content" data-v-cfb513e0><div class="content-container" data-v-cfb513e0><!--[--><!--]--><main class="main" data-v-cfb513e0><div style="position:relative;" class="vp-doc _interview_web_vue" data-v-cfb513e0><div><h1 id="vue面试题" tabindex="-1">Vue面试题 <a class="header-anchor" href="#vue面试题" aria-hidden="true">#</a></h1><h2 id="简单介绍vue-js是什么" tabindex="-1">简单介绍Vue.js是什么? <a class="header-anchor" href="#简单介绍vue-js是什么" aria-hidden="true">#</a></h2><p>Vue.js是一款用于构建用户界面的渐进式框架。渐进式框架是Vue.js相比于Angular较为受开发者喜欢的原因之一。这意味着，Vue.js是一个无论项目大小都可以满足开发需求的框架。通俗地讲，Vue.js就是一间已经搭建好的“空屋”。与单纯使用jQuery这种库相比，Vue.js可以更好地实现代码复用、减少工作量。</p><h2 id="vue的优缺点是什么" tabindex="-1">Vue的优缺点是什么? <a class="header-anchor" href="#vue的优缺点是什么" aria-hidden="true">#</a></h2><p>优点：1. 前端专门负责前端页面和特效的编写，后端专门负责后端业务逻辑的处理；2. 前端追求的是页面美观、页面流畅、页面兼容等，而后端追求的是“三高”（高并发、高可用、高性能），让它们负责各自的领域，让专业人员负责处理专业的事情，提高开发效率。</p><p>缺点：1. 当接口发生改变的时候，前后端都需要改变；2. 当发生异常的时候，前后端需要联调。联调是非常浪费时间的。</p><h2 id="使用vue的好处是什么" tabindex="-1">使用Vue的好处是什么? <a class="header-anchor" href="#使用vue的好处是什么" aria-hidden="true">#</a></h2><p>Vue两大特点：响应式编程、组件化。Vue的优势：轻量级框架、简单易学、双向数据绑定、组件化、视图与数据和结构分离、虚拟DOM、运行速度快。</p><h2 id="在vue-js中怎么理解mvvm模式" tabindex="-1">在Vue.js中怎么理解MVVM模式？ <a class="header-anchor" href="#在vue-js中怎么理解mvvm模式" aria-hidden="true">#</a></h2><p>MVVM是Model View ViewModel的缩写。其中Model、View、ViewModel的作用分别如下。</p><ol><li>Model代表数据模型，可以在Model中定义数据修改和操作的业务逻辑。</li><li>View代表UI组件，负责将数据模型转换成UI展现出来。</li><li>ViewModel监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View和Model的对象，连接Model和View。在MVVM架构下，View和Model之间并没有直接的联系，而是通过ViewModel进行交互。Model和ViewModel之间的交互是双向的，因此View数据的变化会同步到Model中，而Model数据的变化也会立即反映到View上。ViewModel通过双向数据绑定把View层和Model层连接了起来，而View和Model之间的同步工作完全是自动的，无须人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM、不需要关注数据状态的同步问题，复杂的数据状态维护完全由MVVM统一管理。</li></ol><h2 id="vue的生命周期是什么" tabindex="-1">Vue的生命周期是什么? <a class="header-anchor" href="#vue的生命周期是什么" aria-hidden="true">#</a></h2><ol><li>beforeCreate()(创建前)在数据观测和初始化事件还未开始时被调用</li><li>created()(创建后)在完成数据观测、属性和方法的运算、初始化事件后被调用，$el属性还没有显示出来</li><li>beforeMount()(载入前)在挂载开始前被调用，相关的render函数首次被调用，实例已完成以下配置：编译模板，把data中的数据和模板生成.html。注意此时还没有挂载.html到页面上。</li><li>mounted()(载入后)在el被新创建的vm.$el替换，并挂载到实例上后被调用。实例已完成以下配置：用上面编译好的.html内容替换el属性指向的DOM对象。注意此时模板中的.html被渲染到.html页面中，此过程中进行Ajax交互。</li><li>beforeUpdate()(更新前)在数据更新前被调用，发生在虚拟DOM重新渲染和打补丁前。在该钩子函数中可以进一步更改状态，不会触发附加的重渲染过程。</li><li>updated()(更新后)在由于数据更改导致的虚拟DOM重新渲染和打补丁后被调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而，在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子函数在服务器端渲染期间不被调用。</li><li>beforeDestroy()(销毁前)在实例销毁前被调用，实例仍然完全可用。</li><li>destroyed()(销毁后)在实例销毁后被调用，调用后，所有的事件监听器会被移除、所有的子实例也会被销毁。该钩子函数在服务器端渲染期间不被调用。</li></ol><h2 id="第一次页面加载会触发哪几个钩子函数" tabindex="-1">第一次页面加载会触发哪几个钩子函数? <a class="header-anchor" href="#第一次页面加载会触发哪几个钩子函数" aria-hidden="true">#</a></h2><p>第一次会触发beforeCreate()、created()、beforeMount()、mounted()，并且在mounted()阶段DOM被渲染完成。</p><h2 id="v-if和v-show有什么区别" tabindex="-1">v-if和v-show有什么区别? <a class="header-anchor" href="#v-if和v-show有什么区别" aria-hidden="true">#</a></h2><ol><li>相同点：两者都是在判断DOM节点是否要显示。</li><li>不同点： <ul><li>实现方式。v-if是根据后面数据的真假值，判断直接从DOM树上删除或重建元素节点；v-show只是修改元素的CSS样式，也就是display的属性值，元素始终在DOM树上。</li><li>编译过程。v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单地基于CSS切换</li><li>编译条件。v-if是惰性的，如果初始条件为假，则什么也不做，只有在条件第一次变为真时才开始局部编译；v-show是在任何条件下（无论首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被保留。</li><li>性能消耗。v-if有较高的切换消耗，不适合做频繁的切换；而v-show有较高的初始渲染消耗，适合做频繁的切换。</li></ul></li></ol><h2 id="vue组件中data为什么必须是函数" tabindex="-1">Vue组件中data为什么必须是函数? <a class="header-anchor" href="#vue组件中data为什么必须是函数" aria-hidden="true">#</a></h2><p>在new Vue()中，data是可以作为一个对象进行操作的。然而，在component中，data只能以函数的形式存在，不能直接将对象赋值给它。</p><p>当data选项是一个函数的时候，每个实例可以维护一份被返回对象的独立备份，这样各个实例中的data不会相互影响，以确保是独立的。如果传给组件的data是一个原始对象，则在建立多个组件实例时，它们就会共用这个data对象，修改其中一个组件实例的数据就会影响其他组件实例的数据。</p><h2 id="前后端渲染各自的优点" tabindex="-1">前后端渲染各自的优点? <a class="header-anchor" href="#前后端渲染各自的优点" aria-hidden="true">#</a></h2><p>前端渲染的优点在于：</p><ol><li>业务分离，后端只需要提供数据接口，前端在开发时也不需要部署对应的后端环境，通过一些代理服务器工具就能远程获取后端数据进行开发，能够提升开发效率；</li><li>计算量转移，原本需要后端渲染的任务转移给了前端，减轻了服务器的压力。</li></ol><p>后端渲染的优点在于：</p><ol><li>对搜索引擎友好；</li><li>首页加载时间短，后端渲染加载完成后就直接显示HTML，但前端渲染在加载完成后还需要有一段JS渲染的时间。</li></ol><h2 id="computed、methods、watch的区别" tabindex="-1">computed、methods、watch的区别? <a class="header-anchor" href="#computed、methods、watch的区别" aria-hidden="true">#</a></h2><ol><li>computed：计算属性是用来声明式地描述一个值依赖了其他的值。当在模板中把数据绑定到一个计算属性上时，Vue会在其依赖的任何值导致该计算属性改变时更新DOM。这个功能是非常强大的，它可以让代码更加声明式、数据驱动且易于维护。</li><li>methods：methods函数绑定事件调用，不会使用缓存。</li><li>watch：监听的是定义的变量。当定义变量的值发生变化时，调用对应的方法。在<code>&lt;div&gt;</code>中编写一个表达式name，在data中写入num和lastname、firstname。在watch中，当num的值发生变化时，就会调用num的方法，方法里面的形参对应的是num的新值和旧值，而在computed中，计算的是name依赖的值，它不能计算在data中已经定义过的变量。</li></ol><h2 id="vue的响应式原理是什么" tabindex="-1">Vue的响应式原理是什么? <a class="header-anchor" href="#vue的响应式原理是什么" aria-hidden="true">#</a></h2><p>当一个Vue实例创建时，Vue会遍历data选项的属性，用Object.defineProperty将它们转为getter/setter，并在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的watcher实例，它会在组件渲染的过程中把属性记录为依赖，然后当依赖项的setter被调用时，会通知watcher重新计算，从而使它关联的组件得以更新。</p><h2 id="vue中key值的作用是什么" tabindex="-1">Vue中Key值的作用是什么? <a class="header-anchor" href="#vue中key值的作用是什么" aria-hidden="true">#</a></h2><p>使用Key来给每个节点做一个唯一标识，Key的作用主要是高效地更新虚拟DOM。另外，在Vue中使用相同标签名元素过渡切换时，也会使用到Key属性，其目的是让Vue可以区分它们，否则Vue只会替换其内部属性，而不会触发过渡效果。</p><h2 id="在vue中做数据渲染的时候-如何保证将数据原样输出" tabindex="-1">在Vue中做数据渲染的时候，如何保证将数据原样输出? <a class="header-anchor" href="#在vue中做数据渲染的时候-如何保证将数据原样输出" aria-hidden="true">#</a></h2><ol><li>v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出。</li><li>v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染。</li><li>：插值表达式，可以直接获取Vue实例中定义的数据或函数。使用插值表达式的时候，值可能闪烁；而使用v-html、v-text时不会闪烁，有值就显示，没有值就会被隐藏。</li></ol><h2 id="vue的双向数据绑定原理是什么" tabindex="-1">Vue的双向数据绑定原理是什么? <a class="header-anchor" href="#vue的双向数据绑定原理是什么" aria-hidden="true">#</a></h2><p>Vue.js采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调。具体步骤如下:</p><p>第一步：需要对Observer的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter。这样给这个对象的某个属性赋值，就会触发setter，那么就能监听到数据变化了。</p><p>第二步：Compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者（一旦数据有变动，收到通知，更新视图）。</p><p>第三步：Watcher订阅者是Observer和Compile间通信的“桥梁”，主要负责做的事情如下。</p><ol><li>在自身实例化时往属性订阅器（dep）中添加自身。</li><li>自身必须有一个update()方法。待属性变动通知dep.notice()时，能调用自身的update()方法，并触发Compile中绑定的回调。</li></ol><p>第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的Model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile间的通信“桥梁”，达到“数据变化→视图更新、视图交互变化→Model数据变更”的双向绑定效果。</p><p><img src="/interview/vue/2.png" alt=""></p><h2 id="transition-和-transition-group-有什么区别" tabindex="-1"><code>&lt;transition&gt;</code>和<code>&lt;transition-group&gt;</code>有什么区别? <a class="header-anchor" href="#transition-和-transition-group-有什么区别" aria-hidden="true">#</a></h2><p>唯一的区别就是<code>&lt;transition&gt;</code>中只能包裹一个元素，而<code>&lt;transition-group&gt;</code>可以包裹多个元素。</p><h2 id="vue中data必须是一个函数吗" tabindex="-1">Vue中data必须是一个函数吗? <a class="header-anchor" href="#vue中data必须是一个函数吗" aria-hidden="true">#</a></h2><p>对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，若在一个组件中修改data，其他重用组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，因此不会出现这个问题。</p><h2 id="过渡动画实现的三种方式是什么" tabindex="-1">过渡动画实现的三种方式是什么? <a class="header-anchor" href="#过渡动画实现的三种方式是什么" aria-hidden="true">#</a></h2><p>第一种：使用Vue的<code>&lt;transition&gt;</code>标签结合CSS样式完成动画。</p><p>第二种：利用Animate.css结合<code>&lt;transition&gt;</code>实现动画。</p><p>第三种：利用Vue中的钩子函数实现动画。</p><h2 id="vue组件间是如何传值通信的" tabindex="-1">Vue组件间是如何传值通信的? <a class="header-anchor" href="#vue组件间是如何传值通信的" aria-hidden="true">#</a></h2><ol><li>父组件与子组件传值。 <ul><li>父组件传值给子组件：子组件通过props方法接收数据。</li><li>子组件传值给父组件：用$emit方法传递参数。</li></ul></li><li>非父子组件间的数据传递，如兄弟组件间传值：用eventBus创建一个事件中心（相当于中转站），用来传递事件和接收事件。此外，也可以用Vuex来实现。</li></ol><h2 id="请阐述vue子组件调用父组件的几种方法" tabindex="-1">请阐述Vue子组件调用父组件的几种方法? <a class="header-anchor" href="#请阐述vue子组件调用父组件的几种方法" aria-hidden="true">#</a></h2><ol><li>直接在子组件中通过this.$parent.event来调用父组件的方法。</li><li>在子组件中用$emit向父组件触发一个事件，父组件监听这个事件。</li></ol><h2 id="什么是虚拟dom" tabindex="-1">什么是虚拟DOM? <a class="header-anchor" href="#什么是虚拟dom" aria-hidden="true">#</a></h2><p>虚拟DOM其实就是一棵以JavaScript对象（VNode节点）作为基础的树，用对象属性来描述节点。实际上，它只是一层对真实DOM的抽象，最终可以通过一系列操作使这棵树映射到真实环境上。</p><p>简单来说，可以把虚拟DOM理解为一个简单的JavaScript对象，并且最少包含标签名（tag）、属性（attrs）和子元素对象（children）三个属性。不同的框架对这三个属性的命名会有所区别。</p><h2 id="route和-router的区别" tabindex="-1">$route和$router的区别? <a class="header-anchor" href="#route和-router的区别" aria-hidden="true">#</a></h2><p>$route是“路由信息”对象，包括path、params、hash、query、fullPath、matched、name等路由信息参数。而$router是“路由实例”对象，包括路由的跳转方法、钩子函数等。</p><h2 id="vue-router有哪几种导航钩子" tabindex="-1">vue-router有哪几种导航钩子? <a class="header-anchor" href="#vue-router有哪几种导航钩子" aria-hidden="true">#</a></h2><ol><li>全局导航钩子。router.beforeEach(to,from,next)，作用是跳转前进行判断拦截。</li><li>组件内的钩子。</li><li>单独路由独享组件。</li></ol><h2 id="vue的基本原理" tabindex="-1">Vue的基本原理 <a class="header-anchor" href="#vue的基本原理" aria-hidden="true">#</a></h2><p>当一个Vue实例创建时，Vue会遍历data中的属性，用Object.defineProperty(vue3.0 使用 proxy)将它们转为getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p><p><img src="/interview/vue/1.png" alt=""></p><h2 id="mvvm、mvc、mvp的区别" tabindex="-1">MVVM、MVC、MVP的区别 <a class="header-anchor" href="#mvvm、mvc、mvp的区别" aria-hidden="true">#</a></h2><p>MVC、MVP和MVVM是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。 在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p><h3 id="mvc" tabindex="-1">MVC <a class="header-anchor" href="#mvc" aria-hidden="true">#</a></h3><p>MVC通过分离Model、View和Controller的方式来组织代码结构。其中View负责页面的显示逻辑，Model负责存储页面的业务数据，以及对相应数据的操作。并且View和Model应用了观察者模式，当Model层发生改变的时候它会通知有关View层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p><h3 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-hidden="true">#</a></h3><p>MVVM 分为 Model、View、ViewModel：Model 代表数据模型，数据和业务逻辑都在 Model 层中定义；View 代表 UI 视图，负责数据的展示； ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作 DOM。</p><h3 id="mvp" tabindex="-1">MVP <a class="header-anchor" href="#mvp" aria-hidden="true">#</a></h3><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的 Controller 只知道Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将Model 的变化和 View 的变化绑定在一起，以此来实现 View 和Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p><h2 id="slot-是什么-有什么作用-原理是什么" tabindex="-1">slot 是什么？有什么作用？原理是什么？ <a class="header-anchor" href="#slot-是什么-有什么作用-原理是什么" aria-hidden="true">#</a></h2><p>slot 又名插槽，是 Vue 的内容分发机制，组件内部的模板引擎使用slot 元素作为承载分发内容的出口。插槽 slot 是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot 又分三类，默认插槽，具名插槽和作用域插槽。</p><p>默认插槽：又名匿名插槽，当 slot 没有指定 name 属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</p><p>具名插槽：带有具体名字的插槽，也就是带有 name 属性的 slot，一个组件可以出现多个具名插槽。</p><p>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</p><p>实现原理：当子组件 vm 实例化时，获取到父组件传入的 slot 标签的内容，存放在 vm.$slot 中，默认插槽为 vm.$slot.default，具名插槽为 <a href="http://vm.$slot.xxx" target="_blank" rel="noreferrer">vm.$slot.xxx</a>，xxx 为插槽名，当组件执行渲染函数时候，遇到 slot 标签，使用$slot 中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h2 id="nexttick-原理及作用" tabindex="-1">$nextTick 原理及作用 <a class="header-anchor" href="#nexttick-原理及作用" aria-hidden="true">#</a></h2><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p><p>nextTick 的 核 心 是 利 用 了 如 Promise 、 MutationObserver 、setImmediate、setTimeout 的原生 JavaScript 方法来模拟对应的 微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p><p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理。</p><p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p><p>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM的渲染，可以减少一些无用渲染</p><p>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</p><p>Vue 采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1 的数据发生了变化，而 DOM2需要从 DOM1 中获取数据，那这时就会发现 DOM2 的视图并没有更新，这时就需要用到了 nextTick 了。</p><p>由于 Vue 的 DOM 操作是异步的，所以，在上面的情况中，就要将 DOM2获取数据的操作写在$nextTick 中</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">$nextTick</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//获取数据的操作</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>所以，在以下情况下，会用到 nextTick：在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的 DOM 结构的时候，这个操作就需要方法在 nextTick()的回调函数中。</p><p>在 vue 生命周期中，如果在 created()钩子进行 DOM 操作，也一定要放在 nextTick()的回调函数中。</p><p>因为在 created()钩子函数中，页面的 DOM 还未渲染，这时候也没办法操作 DOM，所以，此时如果想要操作 DOM，必须将操作的代码放在 nextTick()的回调函数中。</p><h2 id="vue-单页应用与多页应用的区别" tabindex="-1">Vue 单页应用与多页应用的区别 <a class="header-anchor" href="#vue-单页应用与多页应用的区别" aria-hidden="true">#</a></h2><p>SPA 单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次 js、css 等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</p><p>MPA 多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载 js、css 等相关资源。多页应用跳转，需要整页资源刷新。</p><table><thead><tr><th>对比项/模式</th><th>SPA</th><th>MPA</th></tr></thead><tbody><tr><td>结构</td><td>一个主页面+许多模块的组件</td><td>许多完整的页面</td></tr><tr><td>体验</td><td>页面切换快，体验佳。当初次加载文件过多时，需要做相关的调优</td><td>页面切换慢，网速慢的时候，体验尤其不好</td></tr><tr><td>资源文件</td><td>组件公用的资源只需要加载一次</td><td>每个页面都要自己加载公用的资源</td></tr><tr><td>适用场景</td><td>对体验度和流畅度有较高要求的应用，不利于SEO(可借助SSR优化SEO)</td><td>适用于对SEO要求较高的应用</td></tr><tr><td>过渡动画</td><td>Vue提供了transition的封装组件，容易实现</td><td>很难实现</td></tr><tr><td>内容更新</td><td>相关组件的切换，即局部更新</td><td>整体HTML的切换，费钱(重复HTTP请求)</td></tr><tr><td>路由模式</td><td>可以使用hash，也可以使用history</td><td>普通链接跳转</td></tr><tr><td>数据传递</td><td>因为单页面，使用全局变量就好(Vuex)</td><td>cookie、localstorage等缓存方案，URL参数，调用接口保存等</td></tr><tr><td>相关成本</td><td>前期开发成本较高，后期维护较为容易</td><td>前期开发成本低，后期维护就比较麻烦，因为一个功能需要改很多地方</td></tr></tbody></table><h2 id="vue-中封装的数组方法有哪些-其如何实现页面更新" tabindex="-1">Vue 中封装的数组方法有哪些，其如何实现页面更新 <a class="header-anchor" href="#vue-中封装的数组方法有哪些-其如何实现页面更新" aria-hidden="true">#</a></h2><p>在 Vue 中，对响应式处理利用的是 Object.defineProperty 对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数 组的截取变化等，所以需要对这些操作进行 hack，让 Vue 能监听到其中的变化。</p><p>Vue将被侦听的数据的变更方法进行了包裹，所以他们也将会触发视图更新。这些被包裹过的方法包括：</p><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><p>那 Vue 是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue 中对这些方法的封装</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> arrayProto </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> arrayMethods </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(arrayProto)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> methodsToPatch </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">push</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pop</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">shift</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">unshift</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">splice</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">sort</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">reverse</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * Intercept mutating methods and emit events</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#A6ACCD;">methodsToPatch</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">method</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// cache original method</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">original</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">arrayProto</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">method</span><span style="color:#F07178;">]</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">def</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">arrayMethods</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">method</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">mutator</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(...</span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">original</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">apply</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">args</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ob</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">__ob__</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">inserted</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">switch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">method</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">push</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">unshift</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">inserted</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">args</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">break</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">splice</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">inserted</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">args</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">slice</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">2</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">break</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">inserted</span><span style="color:#F07178;">) </span><span style="color:#A6ACCD;">ob</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">observeArray</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">inserted</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// notify change</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">ob</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">dep</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">notify</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">result</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的 Observer 对象，如果有新的值，就调用 observeArray 继续对新的值观察变化（也就是通过 target__proto__== arrayMethods 来改变了数组实例的型），然后手动调用 notify， 通知渲染 watcher，执行 update。</p><h2 id="vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" tabindex="-1">Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗? <a class="header-anchor" href="#vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" aria-hidden="true">#</a></h2><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环 tick 中，Vue 刷新队列并执行实际（已去重的）工作</p><h2 id="简述-mixin、extends-的覆盖逻辑" tabindex="-1">简述 mixin、extends 的覆盖逻辑 <a class="header-anchor" href="#简述-mixin、extends-的覆盖逻辑" aria-hidden="true">#</a></h2><ol><li>mixin 和 extends</li></ol><p>mixin 和 extends 均是用于合并、拓展组件的，两者均通过mergeOptions 方法实现合并。mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</p><table><thead><tr><th>属性名称</th><th>合并策略</th><th>对应合并函数</th></tr></thead><tbody><tr><td>data</td><td>mixins/extends只会将自己有的但是组件上没有内容混合到组件上，重复定义默认使用组件上的，如果data里的值是对象，将递归内部对象继续按照该策略合并</td><td>mergeDataOrFn,mergeData</td></tr><tr><td>provide</td><td>同上</td><td>mergeDataOrFn,mergeData</td></tr><tr><td>props</td><td>mixins/extends只会将自己有的但是组件上没有内容混合到组件上</td><td>extend</td></tr><tr><td>methods</td><td>同上</td><td>extend</td></tr><tr><td>inject</td><td>同上</td><td>extend</td></tr><tr><td>computed</td><td>同上</td><td>extend</td></tr><tr><td>组件、过滤器、指令属性</td><td>同上</td><td>extend</td></tr><tr><td>el</td><td>同上</td><td>defaultStrat</td></tr><tr><td>propsData</td><td>同上</td><td>defaultStrat</td></tr><tr><td>watch</td><td>合并watch监控的回调方法，执行顺序是先mixins/extends里watch定义的回调，然后是组件的回调</td><td>starts,watch</td></tr><tr><td>HOOKS声明周期钩子</td><td>同一种钩子的回调函数会被合并成数组，执行顺序是先mixins/extends里定义的钩子函数，然后才是组件里定义的</td><td>mergeHook</td></tr></tbody></table><ol start="2"><li>mergeOptions 的执行过程</li></ol><p>规范化选项（normalizeProps、normalizelnject、 normalizeDirectives)对未合并的选项，进行判断</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">child</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">_base)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">child</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">extends</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">parent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">mergeOptions</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">child</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">extends</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">vm</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">child</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">mixins</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;">(</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">=</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">l</span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;">child</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">mixins</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">l</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">i</span><span style="color:#89DDFF;">++</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">parent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">mergeOptions</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">parent</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">child</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">mixins</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">vm</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="子组件可以直接改变父组件的数据吗" tabindex="-1">子组件可以直接改变父组件的数据吗? <a class="header-anchor" href="#子组件可以直接改变父组件的数据吗" aria-hidden="true">#</a></h2><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p><p>Vue 提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><h2 id="对-react-和-vue-的理解-它们的异同" tabindex="-1">对 React 和 Vue 的理解，它们的异同 <a class="header-anchor" href="#对-react-和-vue-的理解-它们的异同" aria-hidden="true">#</a></h2><p>相似之处：</p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li><li>都使用了 Virtual DOM（虚拟 DOM）提高重绘性能；</li><li>都有 props 的概念，允许组件间的数据传递；</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li></ul><p>不同之处：</p><ul><li>数据流：Vue 默认支持数据双向绑定，而 React 一直提倡单向数据流</li><li>虚拟 DOM：Vue2.x 开始引入&quot;Virtual DOM&quot;，消除了和 React 在这方面的差异，但是在具体的细节还是有各自的特点。Vue 宣称可以更快地计算出 Virtual DOM 的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。对于 React 而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate 这个生命周期方法来进行控制，但 Vue 将此视为默认的优化。</li><li>组件化：React 与 Vue 最大的不同是模板的编写。Vue 鼓励写近似常规 HTML 的模板。写起来很接近标准 HTML 元素，只是多了一些属性。React 推荐你所有的模板通用 JavaScript 的语法扩展——JSX 书写。具体来讲：React 中 render 函数是支持闭包特性的，所以 import 的 组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了 之后，还需要在 components 中再声明下。</li><li>监听数据变化的实现原理不同：Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能 React 默 认 是 通 过 比 较 引 用 的 方 式 进 行 的 ， 如 果 不 优 化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM 的重新渲染。这是因为 Vue 使用的是可变数据，而 React 更强调数据的不可变。</li><li>高阶组件：react 可以通过高阶组件（HOC）来扩展，而 Vue 需要通过 mixins 来扩展。高阶组件就是高阶函数，而 React 的组件本身就是纯粹的函数，所以高阶函数对 React 来说易如反掌。相反 Vue.js 使用 HTML 模板创建视图组件，这时模板无法有效的编译，因此 Vue 不能采用 HOC 来实现。</li><li>构建工具：两者都有自己的构建工具：React ==&gt; Create React APP，Vue ==&gt; vue-cli</li><li>跨平台：React ==&gt; React Native，Vue ==&gt; Weex</li></ul><h2 id="vue的优点" tabindex="-1">Vue的优点 <a class="header-anchor" href="#vue的优点" aria-hidden="true">#</a></h2><ul><li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；</li><li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li><li>双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；</li><li>组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</li><li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li><li>虚拟 DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；</li><li>运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue存在很大的优势</li></ul><h2 id="assets-和-static-的区别" tabindex="-1">assets 和 static 的区别 <a class="header-anchor" href="#assets-和-static-的区别" aria-hidden="true">#</a></h2><ul><li><p>相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p></li><li><p>不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p></li></ul><p>建议： 将项目中 template 需要的样式文件 js 文件等都可以放置在assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如 iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p><h2 id="delete-和-vue-delete-删除数组的区别" tabindex="-1">delete 和 Vue.delete 删除数组的区别 <a class="header-anchor" href="#delete-和-vue-delete-删除数组的区别" aria-hidden="true">#</a></h2><p>delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。</p><p>Vue.delete 直接删除了数组 改变了数组的键值</p><h2 id="vue-模版编译原理" tabindex="-1">Vue 模版编译原理 <a class="header-anchor" href="#vue-模版编译原理" aria-hidden="true">#</a></h2><p>vue 中的模板 template 无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的 HTML 语法，所有需要将 template 转化成一个 JavaScript 函数，这样浏览器就可以执行这一个函数并渲染出对应的 HTML 元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析 parse，优化 optimize，生成 generate，最终生成可执行函数 render。</p><ul><li>解析阶段：使用大量的正则表达式对 template 字符串进行解析，将标签、指令、属性等转化为抽象语法树 AST。</li><li>优化阶段：遍历 AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行 diff 比较时，直接跳过这一些静态节点，优化 runtime 的性能。</li><li>生成阶段：将最终的 AST 转化为 render 函数字符串。</li></ul><h2 id="vue-初始化页面闪动问题" tabindex="-1">vue 初始化页面闪动问题 <a class="header-anchor" href="#vue-初始化页面闪动问题" aria-hidden="true">#</a></h2><p>使用 vue 开发时，在 vue 初始化之前，由于 div 是不归 vue 管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类 似于<code></code>的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p><p>首先：在 css 里加上以下代码：</p><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">[</span><span style="color:#C792EA;">v-cloak</span><span style="color:#89DDFF;">]{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">display</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">none</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display:none;&quot; :style=&quot;{display: &#39;block&#39;}</code></p><h2 id="mvvm-的优缺点" tabindex="-1">MVVM 的优缺点? <a class="header-anchor" href="#mvvm-的优缺点" aria-hidden="true">#</a></h2><p>优点:</p><p>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定不同的&quot;View&quot;上，当 View 变化的时候 Model不可以不变，当 Model 变化的时候 View 也可以不变。你可以把⼀些视图逻辑放在⼀个 ViewModel⾥⾯，让很多 view 重⽤这段视图逻辑提⾼可测试性: ViewModel 的存在可以帮助开发者更好地编写测试代码。</p><p>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动 dom 中解放。</p><p>缺点:</p><p>Bug 很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得⼀个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在 View 的模版当中的，这些内容是没办法去打断点 debug 的⼀个⼤的模块中 model 也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存。对于⼤型的图形应⽤程序，视图状态较多，ViewModel 的构建和维护的成本都会⽐较⾼</p><h2 id="v-if-和-v-for-哪个优先级更高-如果同时出现-应如何优化" tabindex="-1">v-if 和 v-for 哪个优先级更高？如果同时出现，应如何优化 <a class="header-anchor" href="#v-if-和-v-for-哪个优先级更高-如果同时出现-应如何优化" aria-hidden="true">#</a></h2><p>v-for 优先于 v-if 被解析，如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能。</p><p>要避免出现这种情况，则在外层嵌套 template，在这一层进行 v-if判断，然后在内部进行 v-for 循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项。</p><h2 id="对-vue-组件化的理解" tabindex="-1">对 Vue 组件化的理解 <a class="header-anchor" href="#对-vue-组件化的理解" aria-hidden="true">#</a></h2><ol><li>组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；</li><li>组件化开发能大幅提高应用开发效率、测试性、复用性等；</li><li>组件使用按分类有：页面组件、业务组件、通用组件；</li><li>vue 的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于 VueComponent，扩展于Vue；</li><li>vue 中常见组件化技术有：属性 prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；6.合理的划分组件，有助于提升应用性能；</li><li>组件应该是高内聚、低耦合的；</li><li>遵循单向数据流的原则。</li></ol><h2 id="对-vue-设计原则的理解" tabindex="-1">对 vue 设计原则的理解 <a class="header-anchor" href="#对-vue-设计原则的理解" aria-hidden="true">#</a></h2><ol><li>渐进式 JavaScript 框架：与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</li><li>易用性：vue 提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html 和 css 就能轻松编写 vue 应用。</li><li>灵活性：渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要 vue 核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli 等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。</li><li>高效性：超快的虚拟 DOM 和 diff算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3 中引入 Proxy 对数据响应式改进以及编译器中对于静态内容编译的改进都会让 vue 更加高效。</li></ol><h2 id="说一下-vue-的生命周期" tabindex="-1">说一下 Vue 的生命周期 <a class="header-anchor" href="#说一下-vue-的生命周期" aria-hidden="true">#</a></h2><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是 Vue 的⽣命周期。</p><ol><li>beforeCreate（创建前）：数据观测和初始化事件还未开始，此时data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到 data、computed、watch、methods 上的方法和数据。</li><li>created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 $el 属性。</li><li>beforeMount（挂载前）：在挂载开始之前被调用，相关的 render函数首次被调用。实例已完成以下的配置：编译模板，把 data 里面的数据和模板生成 html。此时还没有挂载 html 到页面上。</li><li>mounted（挂载后）：在 el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互。</li><li>beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li><li>updated（更新后） ：在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li><li>beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例。</li><li>destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li></ol><p>另外还有 keep-alive 独有的生命周期，分别为 activated 和deactivated。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated钩子函数。</p><h2 id="vue-子组件和父组件执行顺序" tabindex="-1">Vue 子组件和父组件执行顺序 <a class="header-anchor" href="#vue-子组件和父组件执行顺序" aria-hidden="true">#</a></h2><p>加载渲染过程：</p><ol><li>父组件 beforeCreate</li><li>父组件 created</li><li>父组件 beforeMount</li><li>子组件 beforeCreate</li><li>子组件 created</li><li>子组件 beforeMount</li><li>子组件 mounted</li><li>父组件 mounte</li></ol><p>更新过程：</p><ol><li>父组件 beforeUpdate</li><li>子组件 beforeUpdate</li><li>子组件 updated</li><li>父组件 updated</li></ol><p>销毁过程：</p><ol><li>父组件 beforeDestroy</li><li>子组件 beforeDestroy</li><li>子组件 destroyed</li><li>父组件 destoryed</li></ol><h2 id="created-和-mounted-的区别" tabindex="-1">created 和 mounted 的区别 <a class="header-anchor" href="#created-和-mounted-的区别" aria-hidden="true">#</a></h2><p>created:在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。</p><p>mounted:在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作</p><h2 id="一般在哪个生命周期请求异步数据" tabindex="-1">一般在哪个生命周期请求异步数据 <a class="header-anchor" href="#一般在哪个生命周期请求异步数据" aria-hidden="true">#</a></h2><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li><li>SSR 不支持 beforeMount 、mounted 钩子函数，放在 created 中有 助于一致性。</li></ul><h2 id="keep-alive-中的生命周期哪些" tabindex="-1">keep-alive 中的生命周期哪些 <a class="header-anchor" href="#keep-alive-中的生命周期哪些" aria-hidden="true">#</a></h2><p>keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。</p><p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p><p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。</p><h2 id="路由的-hash-和-history-模式的区别" tabindex="-1">路由的 hash 和 history 模式的区别 <a class="header-anchor" href="#路由的-hash-和-history-模式的区别" aria-hidden="true">#</a></h2><p>Vue-Router 有两种模式：hash 模式和 history 模式。默认的路由模式是 hash 模式。</p><ol><li>hash 模式</li></ol><p>简介： hash 模式是开发中默认的模式，它的 URL 带着一个#，例如：<code>http://www.abc.com/#/vue</code>，它的 hash 值就是#/vue。特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。</p><p>原理： hash 模式的主要原理就是 onhashchange()事件</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onhashchange</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">event</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">oldURL</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">newURL</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hash</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">location</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hash</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">slice</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>使用 onhashchange()事件的好处就是，在页面的 hash 值发生变化时，无需向后端发起请求，window 就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash 值变化对应的 URL 都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的 hash 值和对应的 URL 关联起来了。</p><ol start="2"><li>history 模式</li></ol><p>简介： history 模式的 URL 中没有#，它使用的是传统的路由分发模式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。</p><p>特 点 ： 当 使 用 history 模 式 时 ， URL 就 像 这 样 ：<code>http://abc.com/user/id</code>。相比 hash 模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。</p><p>API： history api 可以分为两大部分，切换历史状态和修改历史状态：</p><ul><li>修 改 历 史 状 态 ： 包 括 了 HTML5 History Interface 中 新 增 的pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。</li><li>切换历史状态： 包括 forward()、back()、go()三个方法，对应浏览器的前进，后退，跳转操作。</li></ul><p>虽然 history 模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。如果想要切换到 history 模式，就要进行以下配置（后端也要进行配置）</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> router </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">VueRouter</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">mode</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">history</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">routes</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">[</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="3"><li>两种模式对比</li></ol><p>调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p><ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的URL；</li><li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li><li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li><li>pushState() 可额外设置 title 属性供后续使用。</li></ul><p>hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，前端的 url 必须和实际向后端发起请求的 url 一致，如果没有对用的路由处理，将返回 404 错误。hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p><h2 id="vue-router-跳转和-location-href-有什么区别" tabindex="-1">Vue-router 跳转和 location.href 有什么区别 <a class="header-anchor" href="#vue-router-跳转和-location-href-有什么区别" aria-hidden="true">#</a></h2><p>使用 location.href= /url 来跳转，简单方便，但是刷新了页面；使用 history.pushState( /url ) ，无刷新页面，静态跳转；</p><p>引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为 vue-router 就是用了 history.pushState() ，尤其是在 history 模式下。</p><h2 id="vuex-的原理" tabindex="-1">Vuex 的原理 <a class="header-anchor" href="#vuex-的原理" aria-hidden="true">#</a></h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>改 变 store 中 的 状 态 的 唯 一 途 径 就 是 显 式 地 提 交 (commit)mutation。这样可以方便地跟踪每一个状态的变化。</p></div></div></main><!--[--><!--]--><footer class="VPDocFooter" data-v-cfb513e0 data-v-21f75714><div class="edit-info" data-v-21f75714><!----><div class="last-updated" data-v-21f75714><p class="VPLastUpdated" data-v-21f75714 data-v-18fe8fc2>最近更新时间: <time datetime="2022-12-28T17:24:48.000Z" data-v-18fe8fc2></time></p></div></div><div class="prev-next" data-v-21f75714><div class="pager" data-v-21f75714><a class="pager-link prev" href="/interview/web/network.html" data-v-21f75714><span class="desc" data-v-21f75714>上一页</span><span class="title" data-v-21f75714>网络</span></a></div><div class="has-prev pager" data-v-21f75714><a class="pager-link next" href="/interview/web/skills.html" data-v-21f75714><span class="desc" data-v-21f75714>下一页</span><span class="title" data-v-21f75714>面试套路</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter has-sidebar" data-v-f44a984a data-v-9f24cc86><div class="container" data-v-9f24cc86><p class="message" data-v-9f24cc86>Released under the MIT License.</p><p class="copyright" data-v-9f24cc86>Copyright © 2022-present codeteenager</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"39139fdd\",\"web_introduction.md\":\"09b94c15\",\"web_skills.md\":\"4a363214\",\"web_algorithm.md\":\"507b8ac6\",\"web_program.md\":\"ef963049\",\"web_network.md\":\"635cd2d0\",\"web_other.md\":\"e76d11cd\",\"web_vue.md\":\"4aeca890\",\"web_javascript.md\":\"a65e91e4\"}")</script>
    <script type="module" async src="/interview/assets/app.fbfe15fc.js"></script>
    
  </body>
</html>